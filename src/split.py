#!/usr/bin/python
import settings 
import argparse 
import simplejson
import music21

#TODO:
#     1. multiple time signature
#     2. multiple key
#     3. Test if there will be long rests before first note

#def findScoreInfo(score, infoClass): #infoClass can be TImeSignature or other

def computeTimeSigList(origScore):
   sparseElems= origScore.getElementsByClass(music21.meter.TimeSignature)
   notes = origScore.flat.notes
   if len(sparseElems) == 0:
      #use 4/4 as default, need a smart method to determin
      #or maybe specifiy by command line
      print('[WARN] No time signature found in original score! Default 4/4 used')
      return [music21.meter.TimeSignature('4/4')]*len(notes)
   elif len(sparseElems) == 1:
      return [sparseElems[0]]*len(origScore.flat.notes)
   else:
      elemList = []
      elemIter = iter(sparseElems)
      currElem = elemIter.next()
      nextElem = elemIter.next()
      for note in notes:
         if note.offset > nextElem.offset:
            currElem = nextElem
            try:
               nextElem = elemIter.next()
            except StopIteration:
               pass 
            elemList.append(currElem)
         else:
            elemList.append(currElem)
      return elemList

def writeSegments(splitRec, scoreElemsAll, origScore, 
                  outputDir, scoreFilename, counter = 1): #score needs to be flat
   #see split for def of scoreElemsAll
   if len(splitRec) == 0:
      return 

   splitRecHead = splitRec[0]
   splitRecTail = splitRec[1:]
   scoreElemsAllHead = scoreElemsAll[0]
   scoreElemsAllTail = scoreElemsAll[1:]

   minOffset = min(splitRecHead)
   maxOffset = max(splitRecHead)
   settings.printDebug(origScore)
   scoreSegment = (origScore.flat.getElementsByOffset(minOffset, maxOffset))
   if settings.DEBUG:
      settings.printDebug('')
      scoreSegment.show('text')

   settings.printDebug(scoreSegment[0].offset)
   for scoreElem in scoreElemsAllHead:
      scoreSegment.insert(scoreSegment[0].offset, scoreElem)

   if settings.DEBUG:
      settings.printDebug('')
      scoreSegment.show('text')
   #settings.printDebug(scoreSegment.notes[0])
   #settings.printDebug(scoreSegment.notes[0].beat)

   scoreSegment.shiftElements(-(scoreSegment.lowestOffset)) 
   # segment no >2 need shift, or will have heading rests

   # If not start at first beat, insert rests
   # However, the "beat" is right but "offset" is not. 
   # Inserting rest will increase readability. But may screw up beat
   startBeat = scoreSegment.notes[0].beat 
   if startBeat > 1: # If not start at first beat, insert rests
      r = music21.note.Rest(quarterLength=(startBeat-1))
      settings.printDebug(r.quarterLength)
      scoreSegment.insertAndShift(scoreSegment.notes[0].offset, r)

   if settings.DEBUG:
      settings.printDebug('')
      scoreSegment.show('text')
      


   scoreMeasures = scoreSegment.makeMeasures()

   #splittedScoreFilename = outputDir + scoreName 
   #splittedScoreFilename += '.'+ str(counter) + '.score.xml'
   splittedScoreFilename = settings.getSplittedScoreFilename(counter, 
                                                             scoreFilename, 
                                                             outputDir)
   scoreMeasures.write(settings.defaultScoreFormatName, splittedScoreFilename)
   print('[INFO] Splitted score saved to ' + splittedScoreFilename)

   writeSegments(splitRecTail, scoreElemsAllTail, origScore, 
                 outputDir, scoreFilename, counter+1)
   return 

def split(splitRecFilename, origScoreFilename, outputDir):
   with open(splitRecFilename, 'r') as f:
      splitRec = simplejson.load(f)
   origScore = music21.converter.parse(origScoreFilename)

   timeSigList = computeTimeSigList(origScore)
   settings.printDebug(timeSigList)   

   #scoreElemsAll is all notational elements for each segments
   #e.g. [[timeSig1, key1], [timeSig2, key2]...]
   scoreElemsAll= zip(timeSigList) #may have key etc 

   #for offsetSegment, scoreElems in zip(splitRec, scoreElemsAll):
   writeSegments(splitRec, scoreElemsAll, origScore, outputDir, origScoreFilename)



if __name__ == "__main__":
   parser = argparse.ArgumentParser()
   parser.add_argument("split", 
                       help="Path to split record generated by recordExprPerf.py",
                      )
   parser.add_argument("score",  
                       help="Path to score file",
                      )
   parser.add_argument("outputDir",  
                       help="Output Directory",
                      )
   args = parser.parse_args()
   split(args.split, args.score, args.outputDir)
